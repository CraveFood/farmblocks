{"version":3,"file":"main.6b7cebb41d00431f5829.bundle.js","sources":["webpack:///./packages/input-text/src/protectedValue.js"],"sourcesContent":["import * as React from \"react\";\nimport PropTypes from \"prop-types\";\nimport styled from \"styled-components\";\n\nimport { colors } from \"@crave/farmblocks-theme\";\nimport Button, { buttonTypes, buttonSizes } from \"@crave/farmblocks-button\";\nimport { formInputProps, styledInput } from \"@crave/farmblocks-hoc-input\";\n\n// the cover of a protected field is a div (instead of an input) enhanced with formInput hoc and some extra style overridings\nconst Cover = styled(styledInput)`\n  display: block;\n\n  .input {\n    position: absolute;\n    width: 100%;\n    height: 48px;\n    padding: 16px;\n    bottom: 0;\n    background: ${colors.SUGAR};\n    color: ${colors.CARBON};\n    box-shadow: none;\n    cursor: auto;\n  }\n  .clear {\n    position: absolute;\n    right: 0px;\n  }\n`;\nCover.displayName = \"InputCover\";\n\nconst Container = styled.div`\n  position: relative;\n  display: ${props => props.isEditing && \"flex\"};\n  align-items: flex-end;\n\n  > :first-child {\n    flex-grow: 1;\n  }\n\n  .margin-button {\n    margin: 0 8px;\n  }\n`;\n\n// extra properties supported/extended by the protected field HOC\nexport const protectedValueProps = {\n  protected: PropTypes.bool,\n  onUncover: PropTypes.func,\n  onReplace: PropTypes.func,\n  onCancel: PropTypes.func,\n  onKeyDown: PropTypes.func,\n  cancelButtonText: PropTypes.string,\n  saveButtonText: PropTypes.string,\n  disableManualReplace: PropTypes.bool,\n};\n\n// HOC that covers a component with a dummy text field\n// until the edit button is clicked\nexport default WrappedComponent => {\n  return class ProtectedInput extends React.Component {\n    state = {\n      isEditing: false,\n      value: this.props.value,\n      editedValue: \"\",\n    };\n\n    componentDidUpdate = prevProps => {\n      if (this.props.value !== prevProps.value) {\n        this.setState({\n          value: this.props.value,\n        });\n      }\n    };\n\n    onUncover = () => {\n      this.setState({ isEditing: true, editedValue: \"\" });\n      this.props.onUncover?.();\n    };\n\n    onCancel = () => {\n      this.setState({ isEditing: false, editedValue: \"\" });\n      return this.props.onCancel && this.props.onCancel();\n    };\n\n    onReplace = value => {\n      this.setState({ value, isEditing: false, editedValue: \"\" });\n      return this.props.onReplace && this.props.onReplace(value);\n    };\n\n    renderCover = () => {\n      return (\n        <Cover>\n          <div className=\"input\">\n            {this.state.value}\n            {!this.props.disabled && (\n              <div className=\"clear\">\n                <a\n                  role=\"link\"\n                  tabIndex=\"0\"\n                  onClick={this.onUncover}\n                  onKeyDown={this.onUncover}\n                >\n                  <i className=\"wg-edit\" />\n                </a>\n              </div>\n            )}\n          </div>\n        </Cover>\n      );\n    };\n\n    // protected fields will listen to Enter key as an OK and Esc key as Cancel\n    onKeyDown = evt => {\n      if (evt.key === \"Enter\") {\n        const { value } = evt.target;\n        this.onReplace(value);\n      }\n      if (evt.key === \"Escape\") {\n        this.onCancel();\n      }\n      return this.props.onKeyDown && this.props.onKeyDown(evt);\n    };\n\n    render() {\n      const {\n        protected: covered,\n        disableManualReplace,\n        onReplace,\n        onKeyDown,\n        onUncover,\n        cancelButtonText,\n        saveButtonText,\n        focused,\n        ...wrappedComponentProps\n      } = this.props;\n      const { isEditing } = this.state;\n\n      const displayButtons = !disableManualReplace;\n\n      return (\n        <Container isEditing={isEditing}>\n          <WrappedComponent\n            {...wrappedComponentProps}\n            protected={covered}\n            focused={covered ? this.state.isEditing : focused}\n            value={isEditing ? this.state.editedValue : this.state.value}\n            onKeyDown={covered && displayButtons ? this.onKeyDown : onKeyDown}\n            onChange={event => {\n              this.setState({ editedValue: event.target.value });\n              this.props.onChange?.(event);\n            }}\n            onBlur={event => {\n              if (covered && isEditing) {\n                this.onCancel();\n              }\n              this.props.onBlur?.(event);\n            }}\n          />\n          {covered && !isEditing && this.renderCover()}\n          {covered && displayButtons && isEditing && (\n            <div>\n              <Button\n                id=\"cancel-button\"\n                onClick={this.onCancel}\n                size={buttonSizes.MEDIUM}\n                className=\"margin-button\"\n              >\n                {cancelButtonText}\n              </Button>\n              <Button\n                id=\"save-button\"\n                onClick={() => {\n                  this.onReplace(this.state.editedValue);\n                }}\n                onMouseDown={e => {\n                  // We do this in order to avoid onBlur event on input\n                  e.preventDefault();\n                }}\n                type={buttonTypes.SECONDARY}\n                size={buttonSizes.MEDIUM}\n              >\n                {saveButtonText}\n              </Button>\n            </div>\n          )}\n        </Container>\n      );\n    }\n\n    static defaultProps = {\n      cancelButtonText: \"Cancel\",\n      saveButtonText: \"Save\",\n    };\n\n    static propTypes = {\n      ...protectedValueProps,\n      ...formInputProps,\n    };\n  };\n};\n"],"mappings":"AASA","sourceRoot":""}